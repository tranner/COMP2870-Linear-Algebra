<!DOCTYPE html>
<html lang="en"><head>
<script src="lec04_files/libs/clipboard/clipboard.min.js"></script>
<script src="lec04_files/libs/quarto-html/tabby.min.js"></script>
<script src="lec04_files/libs/quarto-html/popper.min.js"></script>
<script src="lec04_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="lec04_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="lec04_files/libs/quarto-html/light-border.css" rel="stylesheet">
<link href="lec04_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="lec04_files/libs/quarto-contrib/live-runtime/live-runtime.js" type="module"></script>
<link href="lec04_files/libs/quarto-contrib/live-runtime/live-runtime.css" rel="stylesheet"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.8.25">

  <meta name="author" content="Dr.&nbsp;Thomas Ranner (Tom)">
  <title>COMP2870 Theoretical Foundations of Computer Science II</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="lec04_files/libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="lec04_files/libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="lec04_files/libs/revealjs/dist/theme/quarto-534cd8e3a96973385dffff3f4709048d.css">
  <link href="lec04_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="lec04_files/libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="lec04_files/libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="lec04_files/libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  <script>
    MathJax = {
      tex: {
        tags: 'ams'  // should be 'ams', 'none', or 'all'
      }
    };
  </script>
  <script type="module" src="lec04_files/libs/quarto-ojs/quarto-ojs-runtime.js"></script>
  <link href="lec04_files/libs/quarto-ojs/quarto-ojs.css" rel="stylesheet">
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">COMP2870 Theoretical Foundations of Computer Science II</h1>
  <p class="subtitle">Iterative solvers for systems of linear equations</p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Dr.&nbsp;Thomas Ranner (Tom) 
</div>
<div class="quarto-title-author-email">
<a href="mailto:T.Ranner@leeds.ac.uk">T.Ranner@leeds.ac.uk</a>
</div>
        <p class="quarto-title-affiliation">
            School of Computer Science, University of Leeds
          </p>
    </div>
</div>

</section>
<section>
<section id="iterative-solutions-of-linear-equations" class="title-slide slide level1 center">
<h1>Iterative solutions of linear equations</h1>
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Module learning objective</strong></p>
</div>
<div class="callout-content">
<p>Apply direct and iterative solvers to solve systems of linear equations; implement methods using floating point numbers and investigate computational cost using computer experiments.</p>
</div>
</div>
</div>
<p>Chapter 5</p>
</section>
<section id="iterative-methods" class="title-slide slide level2 center">
<h2>Iterative methods</h2>
<p>In the previous section we looked at what are known as <em>direct</em> methods for solving systems of linear equations. They are guaranteed to solve with a fixed amount of work (we can even prove this in exact arithmetic!), but this fixed amount of work may be <strong>very</strong> large.</p>
<p>For a general <span class="math inline">\(n \times n\)</span> system of linear equations <span class="math inline">\(A \vec{x} = \vec{b}\)</span>, the computation expense of all direct methods if <span class="math inline">\(O(n^3)\)</span>. The amount of storage required for these approaches is <span class="math inline">\(O(n^2)\)</span> which is dominated by the cost of storing the matrix <span class="math inline">\(A\)</span>. As <span class="math inline">\(n\)</span> becomes larger the storage and computation work required limit the practicality of direct approaches.</p>
</section>
<section id="iterative-methods-1" class="slide level3">
<h3>Iterative methods</h3>
<p>As an alternative, we will propose some <strong>iterative methods</strong>.</p>
<p>Iterative methods produce a sequence <span class="math inline">\((\vec{x}^{(k)})\)</span> of approximations to the solution of the linear system of equations <span class="math inline">\(A \vec{x} = \vec{b}\)</span>.</p>
<p>The iteration is defined recursively and is typically of the form: <span class="math display">\[
\vec{x}^{(k+1)} = \vec{F}(\vec{x}^{(k)}),
\]</span> where <span class="math inline">\(\vec{x}^{(k)}\)</span> is now a vector of values and <span class="math inline">\(\vec{F}\)</span> is some vector function</p>
</section>
<section id="iterative-method-choices" class="slide level3">
<h3>Iterative method choices</h3>
<p>We will need to define</p>
<ul>
<li>choose a starting value <span class="math inline">\(\vec{x}^{(0)}\)</span></li>
<li>the function <span class="math inline">\(\vec{F}\)</span></li>
<li>we still need to decide when we need to stop!</li>
</ul>
<div id="rem-iteration-notation" class="proof remark">
<p><span class="proof-title"><em>Remark 1</em>. </span>We use a value in brackets in the superscript to denote the iteration number to avoid confusion between the iteration number and the component of the vector: <span class="math display">\[
\vec{x}^{(k)} = (\vec{x}^{(k)}_1, \vec{x}^{(k)}_2, \ldots, \vec{x}^{(k)}_n).
\]</span></p>
</div>
</section>
<section id="some-terrible-examples" class="slide level3">
<h3>Some terrible examples</h3>
<p>These are examples of potential iterative methods which would not work very well!</p>
<ol type="1">
<li><p>Consider</p>
<p><span class="math display">\[
\vec{F}(\vec{x}^{(k)}) = \vec{x}^{(k)}.
\]</span></p>
<p>Each iteration is very cheap to compute but very inaccurate – it never converges!</p></li>
</ol>
</section>
<section id="some-terrible-examples-ii" class="slide level3">
<h3>Some terrible examples ii</h3>
<ol start="2" type="1">
<li><p>Consider</p>
<p><span class="math display">\[
\vec{F}(\vec{x}^{(k)}) = \vec{x}^{(k)} + A^{-1} (\vec{b} - A \vec{x}^{(k)}).
\]</span></p>
<p>Each iteration is very expensive to compute – you have to invert <span class="math inline">\(A\)</span>! – but it converges in just one step since</p>
<p><span class="math display">\[
\begin{aligned}
A \vec{x}^{(k+1)} &amp; = A \vec{x}^{(k)} + A A^{-1} (\vec{b} - A \vec{x}^{(k)})
\\
&amp; = A \vec{x}^{(k)} + \vec{b} - A \vec{x}^{(k)} \\
&amp; = \vec{b}.
\end{aligned}
\]</span></p></li>
</ol>
</section>
<section id="general-formula" class="slide level3">
<h3>General formula</h3>
<p>We will construct iterations with</p>
<p><span class="math display">\[\begin{equation}
\label{eq:general-iteration}
\vec{F}(\vec{x}^{(k)}) = \vec{x}^{(k)} + P (\vec{b} - A \vec{x}^{(k)}).
\end{equation}\]</span></p>
<p>for some matrix <span class="math inline">\(P\)</span> such that</p>
<ul>
<li><span class="math inline">\(P\)</span> is easy to compute, or the matrix-vector product <span class="math inline">\(\vec{r} \mapsto P
\vec{r}\)</span> is easy to compute (we call <span class="math inline">\(\vec{b} - A \vec{x}^{(k)} = \vec{r}\)</span> the <strong>residual</strong>.),</li>
<li><span class="math inline">\(P\)</span> approximates <span class="math inline">\(A^{-1}\)</span> well enough that the algorithm converges in few iterations.</li>
</ul>
<p>Note that the above bad examples could be written in the form of <span class="math inline">\(\eqref{eq:general-iteration}\)</span> with <span class="math inline">\(P = O\)</span> (the zero matrix) or <span class="math inline">\(P = A^{-1}\)</span>.</p>
</section>

<section id="jacobi-iteration" class="title-slide slide level2 center">
<h2>Jacobi iteration</h2>
<p>One straightforward choice for <span class="math inline">\(P\)</span> in <span class="math inline">\(\eqref{eq:general-iteration}\)</span> is given by the Jacobi method where we take <span class="math inline">\(P = D^{-1}\)</span> where <span class="math inline">\(D\)</span> is the diagonal of <span class="math inline">\(A\)</span>: <span class="math display">\[
D_{ii} = A_{ii} \quad \text{and} \quad D_{ij} = 0 \text{ for } i \neq j.
\]</span></p>
<p>The <strong>Jacobi iteration</strong> is given by</p>
<p><span class="math display">\[
\vec{x}^{(k+1)} = \vec{x}^{(k)} + D^{-1}(\vec{b} - A \vec{x}^{(k)})
\]</span></p>
</section>
<section id="jacobi-iteration-1" class="slide level3">
<h3>Jacobi iteration</h3>
<p><span class="math inline">\(D\)</span> is a <em>diagonal matrix</em>, so <span class="math inline">\(D^{-1}\)</span> is trivial to form (as long as the diagonal entries are all non-zero): <span class="math display">\[
(D^{-1})_{ii} = \frac{1}{D_{ii}}
\quad \text{and} \quad
(D^{-1})_{ij} = 0 \text{ for } i \neq j.
\]</span></p>
<aside class="notes">
<ul>
<li><p>The cost of one iteration is <span class="math inline">\(O(n^2)\)</span> for a full matrix, and this is dominated by the matrix-vector product <span class="math inline">\(A \vec{x}^{(k)}\)</span>.</p></li>
<li><p>This cost can be reduced to <span class="math inline">\(O(n)\)</span> if the matrix <span class="math inline">\(A\)</span> is sparse - this is when iterative methods are especially attractive (<strong>?@exm-sparse-matrix</strong>).</p></li>
<li><p>The amount of work also depends on the number of iterations required to get a “satisfactory” solution.</p>
<ul>
<li>The number of iterations depends on the matrix;
<ul>
<li>Fewer iterations are needed for a less accurate solution;</li>
</ul></li>
<li>A good initial estimate <span class="math inline">\(\vec{x}^{(0)}\)</span> reduces the required number of iterations.</li>
</ul></li>
<li><p>Unfortunately, the iteration might not converge!</p></li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="update-formula-jacobi" class="slide level3">
<h3>Update formula (Jacobi)</h3>
<p>Given <span class="math inline">\(\vec{x}^{(k)}\)</span>, find <span class="math inline">\(\vec{x}^{(k+1)}\)</span>:</p>
<div style="font-size: 80%">
<p><span class="math display">\[\begin{align*}
x_1^{(k+1)} &amp;= x_1^{(k)} + \frac{1}{A_{11}} \left( b_1 - \sum_{j=1}^n A_{1j}
x_j^{(k)} \right) \\
x_2^{(k+1)} &amp;= x_2^{(k)} + \frac{1}{A_{22}} \left( b_2 - \sum_{j=1}^n A_{2j}
x_j^{(k)} \right) \\
\vdots \quad &amp; \hphantom{=} \quad \vdots \\
x_n^{(k+1)} &amp;= x_n^{(k)} + \frac{1}{A_{nn}} \left( b_n - \sum_{j=1}^n A_{nj}
x_j^{(k)} \right).
\end{align*}\]</span></p>
</div>
<aside class="notes">
<p>The Jacobi iteration updates all elements of <span class="math inline">\(\vec{x}^{(k)}\)</span> <em>simultaneously</em> to get <span class="math inline">\(\vec{x}^{(k+1)}\)</span>:</p>
<p>Note that once the first step has been taken, <span class="math inline">\(x_1^{(k+1)}\)</span> is already known, but the Jacobi iteration does not make use of this information!</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="example" class="slide level3">
<h3>Example</h3>
<p>Take two iterations of Jacobi iteration to approximate the solution of the following system using the initial guess <span class="math inline">\(\vec{x}^{(0)} = (1, 1)^T\)</span>: <span class="math display">\[
\begin{pmatrix}
2 &amp; 1 \\ -1 &amp; 4
\end{pmatrix}
\begin{pmatrix}
x_1 \\ x_2
\end{pmatrix}
=
\begin{pmatrix}
3.5 \\ 0.5
\end{pmatrix}
\]</span></p>
<aside class="notes">
<p>Starting from <span class="math inline">\(\vec{x}^{(0)} = (1, 1)^T\)</span>, the first iteration is <span class="math display">\[
\begin{aligned}
x_1^{(1)} &amp;= x_1^{(0)} + \frac{1}{A_{11}} \left( b_1 - A_{11} x_1^{(0)}
- A_{12} x_2^{(0)} \right) \\
&amp;= 1 + \frac{1}{2} (3.5 - 2 \times 1 - 1 \times 1) = 1.25 \\
x_2^{(1)} &amp;= x_2^{(0)} + \frac{1}{A_{22}} \left( b_2 - A_{21} x_1^{(0)}
- A_{22} x_2^{(0)} \right) \\
&amp;= 1 + \frac{1}{4} (0.5 - (-1) \times 1 - 4 \times 1) = 0.375. \\
\end{aligned}
\]</span> So we have <span class="math inline">\(\vec{x}^{(1)} = (1.25, 0.375)^T\)</span>. Then the second iteration is <span class="math display">\[
\begin{aligned}
x_1^{(2)} &amp;= x_1^{(1)} + \frac{1}{A_{11}} \left( b_1 - A_{11} x_1^{(1)} -
A_{12} x_2^{(1)} \right) \\
&amp;= 1.25 + \frac{1}{2} (3.5 - 2 \times 1.25 - 1 \times 0.375) = 1.5625 \\
x_2^{(2)} &amp;= x_2^{(1)} + \frac{1}{A_{22}} \left( b_2 - A_{21} x_1^{(1)} -
A_{22} x_2^{(1)} \right) \\
&amp;= 0.375 + \frac{1}{4} (0.5 - (-1) \times 1.25 - 4 \times 0.375) = 0.4375. \\
\end{aligned}
\]</span> So we have <span class="math inline">\(\vec{x}^{(2)} = (1.5625, 0.4375)\)</span>.</p>
<p>Note the only difference between the formulae for Iteration 1 and 2 is the iteration number, the superscript in brackets. The exact solution is given by <span class="math inline">\(\vec{x} = (1.5, 0.5)^T\)</span>.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="rewriting-jacobi-iteration" class="slide level3">
<h3>Rewriting Jacobi iteration</h3>
<p>We note that we can also slightly simplify the way the Jacobi iteration is written. We can expand <span class="math inline">\(A\)</span> into <span class="math inline">\(A = L + D + U\)</span>, where <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are the parts of the matrix from below and above the diagonal respectively: <span class="math display">\[
L_{ij} = \begin{cases}
A_{ij} &amp;\quad \text{if } i &lt; j \\
0 &amp;\quad \text{if } i \ge j,
\end{cases}
\qquad
U_{ij} = \begin{cases}
A_{ij} &amp;\quad \text{if } i &gt; j \\
0 &amp;\quad \text{if } i \le j.
\end{cases}
\]</span></p>
</section>
<section id="rewriting-jacobi-iteration-ii" class="slide level3">
<h3>Rewriting Jacobi iteration ii</h3>
<p>Then we can calculate that: <span class="math display">\[
\begin{aligned}
\vec{x}^{(k+1)} &amp; = \vec{x}^{(k)} + D^{-1}(\vec{b} - A \vec{x}^{(k)}) \\
&amp; = \vec{x}^{(k)} + D^{-1}(\vec{b} - (L + D + U) \vec{x}^{(k)}) \\
&amp; = \vec{x}^{(k)} - D^{-1} D \vec{x}^{(k)} + D^{-1}(\vec{b}
- (L + U) \vec{x}^{(k)}) \\
&amp; = \vec{x}^{(k)} - \vec{x}^{(k)} + D^{-1}(\vec{b} - (L + U) \vec{x}^{(k)}) \\
&amp; = D^{-1}(\vec{b} - (L + U) \vec{x}^{(k)}).
\end{aligned}
\]</span></p>
<aside class="notes">
<p>In this formulation, we do not explicitly form the residual as part of the computations. In practical situations, this may be a simpler formulation we can use if we have knowledge of the coefficients of <span class="math inline">\(A\)</span>, rather than just the matrix-vector product.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="gauss-seidel-iteration" class="title-slide slide level2 center">
<h2>Gauss-Seidel iteration</h2>
<p>As an alternative to Jacobi iteration, the iteration might use <span class="math inline">\(x_i^{(k+1)}\)</span> as soon as it is calculated (rather than using the previous iteration):</p>
</section>
<section id="update-formula-gauss-seidel" class="slide level3">
<h3>Update formula (Gauss Seidel)</h3>
<p>Given <span class="math inline">\(\vec{x}^{(k)}\)</span>, find <span class="math inline">\(\vec{x}^{(k+1)}\)</span>:</p>
<div style="font-size: 80%">
<p><span class="math display">\[\begin{align*}
x_1^{(k+1)}
&amp; = x_1^{(k)} + \frac{1}{A_{11}} \left(
b_1 - \sum_{j=1}^n A_{1j} x_j^{(k)}
\right) \\
\vdots \quad &amp; \hphantom{=} \quad \vdots \\
x_i^{(k+1)}
&amp; = x_i^{(k)} + \frac{1}{A_{ii}} \left(
b_i - \sum_{j=1}^{i-1} A_{ij} x_j^{(k+1)} - \sum_{j=i}^n A_{ij} x_j^{(k)}
\right) \\
\vdots \quad &amp; \hphantom{=} \quad \vdots \\
x_n^{(k+1)}
&amp; = x_n^{(k)} + \frac{1}{A_{nn}} \left(
b_n - \sum_{j=1}^{n-1} A_{nj} x_j^{(k+1)} - A_{nn} x_n^{(k)}
\right).
\end{align*}\]</span></p>
</div>
</section>
<section id="matrix-formulation" class="slide level3">
<h3>Matrix formulation</h3>
<p>Consider the system <span class="math inline">\(A \vec{x}= b\)</span> with the matrix <span class="math inline">\(A\)</span> split as <span class="math inline">\(A = L + D + U\)</span>, where <span class="math inline">\(D\)</span> is the diagonal of <span class="math inline">\(A\)</span>, <span class="math inline">\(L\)</span> contains the elements below the diagonal, and <span class="math inline">\(U\)</span> contains the elements above the diagonal. The componentwise iteration above can be written in matrix form as <span class="math display">\[
\vec{x}^{(k+1)} = \vec{x}^{(k)} + (D + L)^{-1} (\vec{b} - A \vec{x}^{(k)}).
\]</span> That is, we use <span class="math inline">\(P = (D+L)^{-1}\)</span> in <span class="math inline">\(\eqref{eq:general-iteration}\)</span>.</p>
<p>In general, we do not form the inverse of <span class="math inline">\(D + L\)</span> explicitly here since it is more complicated to do so than simply computing the inverse of <span class="math inline">\(D\)</span>.</p>
</section>
<section id="example-1" class="slide level3">
<h3>Example</h3>
<p>Take two iterations of Gauss-Seidel iteration to approximate the solution of the following system using the initial guess <span class="math inline">\(\vec{x}^{(0)} = (1, 1)^T\)</span>:</p>
<p><span class="math display">\[
\begin{pmatrix}
2 &amp; 1 \\ -1 &amp; 4
\end{pmatrix}
\begin{pmatrix}
x_1 \\ x_2
\end{pmatrix}
=
\begin{pmatrix}
3.5 \\ 0.5
\end{pmatrix}
\]</span></p>
<aside class="notes">
<p>Starting from <span class="math inline">\(\vec{x}^{(0)} = (1, 1)^T\)</span> we have</p>
<p>Iteration 1:</p>
<p><span class="math display">\[
\begin{aligned}
x^{(1)}_1 &amp; = x^{(0)}_1 + \frac{1}{A_{11}} (b_1 - A_{11} x^{(0)}_1 -
A_{12} x^{(0)}_2) \\
          &amp; = 2 + \frac{1}{2} (3.5 - 1 \times 2 - 1 \times 1) = 2.25 \\
x^{(1)}_2 &amp; = x^{(0)}_2 + \frac{1}{A_{22}} (b_2 - A_{21} x^{(1)}_1 -
A_{22} x^{(0)}_2) \\
          &amp; = 1 + \frac{1}{4} (0.5 - (-1) \times 2.25 - 4 \times 1) = 0.6875.
\end{aligned}
\]</span></p>
<p>Iteration 2:</p>
<p><span class="math display">\[
\begin{aligned}
x^{(2)}_1 &amp; = x^{(1)}_1 + \frac{1}{A_{11}} (b_1 - A_{11} x^{(1)}_1 a
- A_{12} x^{(1)}_2) \\
          &amp; = 1.25 + \frac{1}{2} (3.5 - 2 \times 1.25 - 1 \times 0.4375)
          = 1.53125 \\
x^{(2)}_2 &amp; = x^{(1)}_2 + \frac{1}{A_{22}} (b_2 - A_{21} x^{(2)}_1
- A_{22} x^{(1)}_2) \\
          &amp; = 0.4375 + \frac{1}{4} (0.5 - (-1) \times 1.53125 - 4 \times 0.4375)
          = 0.5078125.
\end{aligned}
\]</span></p>
<p>Again, note the changes in the iteration number on the right-hand side of these equations, especially the differences against the Jacobi method.</p>
<ul>
<li>What happens if the initial estimate is altered to <span class="math inline">\(\vec{x}^{(0)} = (2, 1)^T\)</span>.</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="exercise" class="slide level3">
<h3>Exercise</h3>
<p>Take one iteration of (a) Jacobi iteration; (b) Gauss-Seidel iteration to approximate the solution of the following system using the initial guess <span class="math inline">\(\vec{x}^{(0)} = (1, 2, 3)^T\)</span>:</p>
<p><span class="math display">\[
\begin{pmatrix}
2 &amp; 1 &amp; 0 \\
1 &amp; 3 &amp; 1 \\
0 &amp; 1 &amp; 2
\end{pmatrix}
\begin{pmatrix}
x_1 \\ x_2 \\ x_3
\end{pmatrix}
=
\begin{pmatrix}
6 \\ 10 \\ 6
\end{pmatrix}.
\]</span></p>
<p>Note that the exact solution to this system is <span class="math inline">\(x_1 = 2, x_2 = 2, x_3 = 2\)</span>.</p>
</section>
<section id="remarks" class="slide level3">
<h3>Remarks</h3>
<ul>
<li><p>Here, both methods converge, but relatively slowly. They might not converge at all!</p></li>
<li><p>We will discuss convergence and when to stop later.</p></li>
<li><p>The Gauss-Seidel iteration generally out-performs the Jacobi iteration.</p></li>
<li><p>Performance can depend on the order in which the equations are written.</p></li>
<li><p>Both iterative algorithms can be made faster and more efficient for sparse systems of equations (far more than direct methods).</p></li>
</ul>
</section>

<section id="python-version-of-iterative-methods" class="title-slide slide level2 center">
<h2>Python version of iterative methods</h2>
<div id="5cc7e178" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>jacobi iteration
starting value: x.T = [  1.0,  1.0 ]
after iter=0: x.T = [  1.250,  0.375 ]
after iter=1: x.T = [  1.5625,  0.4375 ]
after iter=2: x.T = [  1.53125,  0.51562 ]
after iter=3: x.T = [  1.49219,  0.50781 ]
after iter=4: x.T = [  1.49609,  0.49805 ]

gauss seidel iteration
starting value: x.T = [  1.0,  1.0 ]
after iter=0: x.T = [  1.2500,  0.4375 ]
after iter=1: x.T = [  1.53125,  0.50781 ]
after iter=2: x.T = [  1.49609,  0.49902 ]
after iter=3: x.T = [  1.50049,  0.50012 ]
after iter=4: x.T = [  1.49994,  0.49998 ]
</code></pre>
</div>
</div>
</section>
<section id="sparse-matrices" class="slide level3">
<h3>Sparse matrices</h3>
<p><strong>Sparse matrices</strong> are prevalent in any application which relies on some form of <em>graph</em> structure (see both the <a href="https://comp2870-2526.github.io/linear-algebra-notes/#exm-temperature">temperature</a> and <a href="https://comp2870-2526.github.io/linear-algebra-notes/#exm-traffic">traffic network</a> examples).</p>
<ul>
<li><p>The <span class="math inline">\(a_{ij}\)</span> typically represents some form of “communication” between vertices <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> of the graph, so the element is only nonzero if the vertices are connected.</p></li>
<li><p>There is no generic pattern for these entries, though there is usually one that is specific to the problem solved.</p></li>
</ul>
</section>
<section id="sparse-matrices-1" class="slide level3">
<h3>Sparse matrices</h3>
<ul>
<li><p>Usually, <span class="math inline">\(a_{ii} \neq 0\)</span> - the diagonal is nonzero.</p></li>
<li><p>A “large” portion of the matrix is zero.</p>
<ul>
<li>A full <span class="math inline">\(n \times n\)</span> matrix has <span class="math inline">\(n^2\)</span> nonzero entries.</li>
<li>A sparse <span class="math inline">\(n \times n\)</span> has <span class="math inline">\(\alpha n\)</span> nonzero entries, where <span class="math inline">\(\alpha \ll
    n\)</span>.</li>
</ul></li>
</ul>
</section>
<section id="sparse-matrices-2" class="slide level3">
<h3>Sparse Matrices</h3>
<p>There are two main ways in which sparse matrices can be exploited in order to obtain benefits within iterative methods.</p>
<ul>
<li><p>The storage can be reduced from <span class="math inline">\(O(n^2)\)</span>.</p></li>
<li><p>The cost per iteration can be reduced from <span class="math inline">\(O(n^2)\)</span>.</p></li>
</ul>
</section>
<section id="storing-a-spare-matrix" class="slide level3">
<h3>Storing a spare matrix</h3>
<p>The simplest way in which a sparse matrix is stored is using three arrays:</p>
<ul>
<li>an array of floating point numbers (<code>A_real</code> say) that stores the non-zero entries;</li>
<li>an array of integers (<code>I_row</code> say) that stores the row number of the corresponding entry in the real array;</li>
<li>an array of integers (<code>I_col</code> say) that stores the column numbers of the corresponding entry in the real array.</li>
</ul>
<p>This requires just <span class="math inline">\(3 \alpha n\)</span> units of storage - i.e.&nbsp;<span class="math inline">\(O(n)\)</span>. This is called the COO (coordinate) format.</p>
</section>
<section id="working-with-a-sparse-matrix" class="slide level3">
<h3>Working with a sparse matrix</h3>
<p>Given the above storage pattern, the following algorithm will execute a sparse matrix-vector multiplication (<span class="math inline">\(\vec{z} = A \vec{y}\)</span>) in <span class="math inline">\(O(n)\)</span> operations:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href=""></a>z <span class="op">=</span> np.zeros((n, <span class="dv">1</span>))</span>
<span id="cb2-2"><a href=""></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(nonzero):</span>
<span id="cb2-3"><a href=""></a>    z[I_row[k]] <span class="op">=</span> z[I_row[k]] <span class="op">+</span> A_real[k] <span class="op">*</span> y[I_col[k]]</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li>Here <code>nonzero</code> is the number of non-zero entries in the matrix.</li>
<li>Note that the cost of this operation is <span class="math inline">\(O(n)\)</span> as required.</li>
</ul>
</section>
<section id="python-experiments" class="slide level3">
<h3>Python experiments</h3>
<p>First let’s adapt our implementations to use this sparse matrix format:</p>
<p>Then we can test the two different implementations of the methods:</p>
<div id="2aaa24e9" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>sparse matrix:
A_real = [ -4.5    6.75   3.75   2.25  -7.5   11.25  26.5    3.75 -13.5   22.5
  11.25   6.75   9.25 -13.5   -7.5   -4.5 ]
I_row =  [0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3]
I_col =  [3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0]

dense matrix:
A_dense = [  2.25,  3.75,  6.75, -4.50 ]
          [  3.75, 26.50, 11.25, -7.50 ]
          [  6.75, 11.25, 22.50, -13.50 ]
          [ -4.50, -7.50, -13.50,  9.25 ]

jacobi with sparse matrix
starting value: x.T = [  0.0,  0.0,  0.0,  0.0 ]
after iter=0: x.T = [  3.66667,  1.28302,  1.20000, -1.75676 ]
after iter=1: x.T = [ -5.58521, -0.24248, -1.59556,  2.81866 ]
after iter=2: x.T = [ 14.4948,  3.5485,  4.6880, -6.9992 ]
after iter=3: x.T = [ -30.3098, -4.7392, -9.1222, 15.0139 ]
after iter=4: x.T = [ 68.960, 13.694, 21.671, -33.658 ]

jacobi with dense matrix
starting value: x.T = [  0.0,  0.0,  0.0,  0.0 ]
after iter=0: x.T = [  3.66667,  1.28302,  1.20000, -1.75676 ]
after iter=1: x.T = [ -5.58521, -0.24248, -1.59556,  2.81866 ]
after iter=2: x.T = [ 14.4948,  3.5485,  4.6880, -6.9992 ]
after iter=3: x.T = [ -30.3098, -4.7392, -9.1222, 15.0139 ]
after iter=4: x.T = [ 68.960, 13.694, 21.671, -33.658 ]
</code></pre>
</div>
</div>
<p>We see that we get the same results!</p>
<p>Now let us see how long it takes to get a solution. The following plot shows the run times of using the two different implementations of the Jacobi method, each for 10 iterations. We see that, as expected, the run time of the dense formulation is <span class="math inline">\(O(n^2)\)</span> and the run time of the sparse formulation is <span class="math inline">\(O(n)\)</span>.</p>
<div id="2589edb8" class="cell" data-execution_count="9">
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img data-src="lec04_files/figure-revealjs/cell-10-output-1.png" width="822" height="431"></p>
</figure>
</div>
</div>
</div>
<p>We say “as expected” because we have already counted the number of operations per iteration and these implementations compute for a fixed number of iterations. In the next section, we look at alternative stopping criteria.</p>
</section>

<section id="convergence-of-an-iterative-method" class="title-slide slide level2 center">
<h2>Convergence of an iterative method</h2>
<p>In general the iteration takes the form <span class="math display">\[
\vec{x}^{(k+1)} = \vec{F}(\vec{x}^{(k)})
\]</span> here <span class="math inline">\(\vec{x}^{(k)}\)</span> is a vector of values and <span class="math inline">\(\vec{F}\)</span> is some vector-valued function which we have defined.</p>
<p>How can we decide if this iteration has converged? We need <span class="math inline">\(\vec{x} -
\vec{x}^{(k)}\)</span> to be small, but we do not have access to the exact solution <span class="math inline">\(\vec{x}\)</span> so we have to do something else!</p>
</section>
<section id="possible-stopping-criteria" class="slide level3">
<h3>Possible stopping criteria?</h3>
<ol type="1">
<li><p>A maximum number of iterations?</p></li>
<li><p>The <em>change</em> in values should be small enough?</p></li>
<li><p>The residual should be small enough?</p></li>
</ol>
</section>
<section id="what-is-a-small-vector" class="slide level3">
<h3>What is a small vector?</h3>
<p>The Euclidean norm, or norm for short, is defined to be the square root of the sum of squares of the entries of the array: <span class="math display">\[
\| \vec{r} \| = \sqrt{ \sum_{i=1}^n r_i^2 }.
\]</span> where <span class="math inline">\(\vec{r}\)</span> is a vector with <span class="math inline">\(n\)</span> entries.</p>
</section>
<section id="examples" class="slide level3">
<h3>Examples</h3>
<p>Consider the following sequence <span class="math inline">\(\vec{x}^{(k)}\)</span>:</p>
<p><span class="math display">\[
\begin{pmatrix}
1 \\ -1
\end{pmatrix},
\begin{pmatrix}
1.5 \\ 0.5
\end{pmatrix},
\begin{pmatrix}
1.75 \\ 0.25
\end{pmatrix},
\begin{pmatrix}
1.875 \\ 0.125
\end{pmatrix},
\begin{pmatrix}
1.9375 \\ -0.0625
\end{pmatrix},
\begin{pmatrix}
1.96875 \\ -0.03125
\end{pmatrix},
\ldots
\]</span></p>
<ul>
<li>What is <span class="math inline">\(\|\vec{x}^{(1)} - \vec{x}^{(0)}\|\)</span>? What is <span class="math inline">\(\|\vec{x}^{(5)} - \vec{x}^{(4)}\|\)</span>?</li>
</ul>
<p>Let <span class="math inline">\(\vec{x} = \begin{pmatrix} 2 \\ 0 \end{pmatrix}\)</span>.</p>
<ul>
<li>What is <span class="math inline">\(\|\vec{x} - \vec{x}^{(3)}\|\)</span>? What is <span class="math inline">\(\|\vec{x} - \vec{x}^{(4)}\|\)</span>? What is <span class="math inline">\(\|\vec{x} - \vec{x}^{(5)}\|\)</span>?</li>
</ul>
</section>
<section id="non-convergence" class="slide level3">
<h3>Non-convergence</h3>
<p>In general there are two possible reasons that an iteration may fail to converge.</p>
<ul>
<li><p>It may <strong>diverge</strong> - this means that <span class="math inline">\(\|\vec{x}^{(k)}\| \to \infty\)</span> as <span class="math inline">\(k\)</span> (the number of iterations) increases, e.g.:</p>
<p><span class="math display">\[
\begin{pmatrix}
1 \\ 1
\end{pmatrix},
\begin{pmatrix}
4 \\ 2
\end{pmatrix},
\begin{pmatrix}
16 \\ 4
\end{pmatrix},
\begin{pmatrix}
64 \\ 8
\end{pmatrix},
\begin{pmatrix}
256 \\ 16
\end{pmatrix},
\begin{pmatrix}
1024 \\ 32
\end{pmatrix},
\ldots
\]</span></p></li>
<li><p>It may <em>neither</em> converge nor diverge, e.g.:</p>
<p><span class="math display">\[
\begin{pmatrix}
1 \\ 1
\end{pmatrix},
\begin{pmatrix}
2 \\ 0
\end{pmatrix},
\begin{pmatrix}
3 \\ 1
\end{pmatrix},
\begin{pmatrix}
1 \\ 0
\end{pmatrix},
\begin{pmatrix}
2 \\ 1
\end{pmatrix},
\begin{pmatrix}
3 \\ 0
\end{pmatrix},
\ldots
\]</span></p></li>
</ul>
<p>In addition to testing for convergence it is also necessary to include tests for failure to converge.</p>
<ul>
<li><p>Divergence may be detected by monitoring <span class="math inline">\(\|\vec{x}^{(k)}\|\)</span>.</p></li>
<li><p>Impose a maximum number of iterations to ensure that the loop is not repeated forever!</p></li>
</ul>
</section>

<section id="summary" class="title-slide slide level2 center">
<h2>Summary</h2>
<ul>
<li><p>Many real-world problems cannot be solved using direct methods. Iterative methods can often be used instead!</p></li>
<li><p>We have introduced two basic iterative methods</p>
<ul>
<li>They are typically slow to converge, and sometimes do not converge at all</li>
<li>The cost per iteration can be improved using a sparse matrix format</li>
</ul></li>
<li><p>More advanced iterative methods do exist but are beyond the scope of this module - see Final year projects, MSc projects, PhD, and beyond!</p></li>
</ul>

<script type="ojs-module-contents">
eyJjb250ZW50cyI6W119
</script>
<div id="exercise-loading-indicator" class="exercise-loading-indicator d-none d-flex align-items-center gap-2">
<div id="exercise-loading-status" class="d-flex gap-2">

</div>
<div class="spinner-grow spinner-grow-sm">

</div>
</div>
<script type="vfs-file">
W10=
</script>
</section>
</section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">

</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="lec04_files/libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="lec04_files/libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="lec04_files/libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="lec04_files/libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="lec04_files/libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="lec04_files/libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="lec04_files/libs/revealjs/plugin/notes/notes.js"></script>
  <script src="lec04_files/libs/revealjs/plugin/search/search.js"></script>
  <script src="lec04_files/libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="lec04_files/libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': true,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script type="ojs-module-contents">
    eyJjb250ZW50cyI6W119
    </script>
    <script type="module">
    if (window.location.protocol === "file:") { alert("The OJS runtime does not work with file:// URLs. Please use a web server to view this document."); }
    window._ojs.paths.runtimeToDoc = "../../..";
    window._ojs.paths.runtimeToRoot = "../../../..";
    window._ojs.paths.docToRoot = "..";
    window._ojs.selfContained = false;
    window._ojs.runtime.interpretFromScriptTags();
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
          const outerScaffold = trigger.parentElement.cloneNode(true);
          const codeEl = outerScaffold.querySelector('code');
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp('/' + window.location.host + '/');
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>